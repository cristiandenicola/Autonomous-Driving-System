-- FILE DI TEST
-- sto provando a ristrutturare il codice principale per migliorarlo e farlo funzionare bene
-- runna questo e non più il main.smv (poi se tutto va bene questo diventerà il main), sia logicamente che a livello codice questo è meglio.

-- l'ho fatto tutto a mano, no chat, cosi è più pulito e sappiamo cosa c'è dentro.

-- MODIFICHE PRINCIPALI:
-- caso base è IDLE non CHECK, quindi la transazione è IDLE -> CHECK -> DRIVING (FUNZIONANTE).
-- no cruise -> è un sistema di guida automatico, va già da solo lol
-- modificati input che possono ricevere gli stati e ordinati per bene.
-- LTLSPEC G (state = DRIVING -> !sensors.obstacle_detected) ORA FUNZIONA
-- aggiunta feature next(lane_position), usata per modificare la posizione in [LEFT, CENTER, RIGHT] quando fa change_lane. FUNZIONA.
-- TURNING ingloba sia left che right, più easy.
-- aggiunti i semafori.

--TODO: PROBLEMI DA RISOLVERE:

-- le sim sono logicamente giuste, ma quando si entra in DRIVING viene spammato l'input detect_obstacle.
-- quindi è sempre un DRIVING -> OBSTACLE_DETECTED -> STOPPED -> DRIVING.

-- LTLSPEC G (state = TURNING -> X(state = DRIVING)).
-- non capisco perchè visto state = TURNING : {turn_completed}; ma mentre si è in TURNING prende input strani ?????

-- per il resto appena si riesce a eliminare il problema 1 bisogna testare gli altri input in DRIVING.

MODULE main

VAR
state : {IDLE, SYSTEM_CHECK, DRIVING, OBSTACLE_DETECTED, STOPPED, PARKED, CHANGING_LANE, TURNING};
input : {
    check_status, 
    no_input, 
    start, 
    detect_obstacle, 
    brake, 
    resume, 
    park, 
    stop, 
    change_lane, 
    change_lane_completed, 
    detect_stop_sign,
    detect_red_light,
    detect_green_light,
    turn,
    turn_completed
};
lane_position : {LEFT, CENTER, RIGHT, NaN}; -- pool per change_lane
sensors : Sensors(input);
maneuver : Maneuver(input);

LTLSPEC G (state = DRIVING -> !sensors.obstacle_detected) --OK
LTLSPEC G (state = DRIVING -> lane_position != NaN) --OK
LTLSPEC G (state = TURNING -> X(state = DRIVING)) --TODO: metterla a posto, per ora rotta.

ASSIGN
    init(state) := IDLE;
    init(input) := no_input; 
    init(lane_position) := NaN;

    -- def of input which cases can have
    next(input) :=
        case
            state = IDLE : {check_status, no_input};
            state = SYSTEM_CHECK : {start};
            state = DRIVING : {
                turn,
                change_lane, 
                detect_stop_sign,
                detect_obstacle, 
                detect_red_light,  
                no_input
            };
            state = TURNING : {turn_completed};
            state = CHANGING_LANE : {change_lane_completed};
            state = OBSTACLE_DETECTED : {brake};
            state = STOPPED : {detect_green_light, resume, park};
            state = PARKED : {stop, no_input};
            TRUE : no_input;
        esac;
    
    next(state) :=
        case
            state = IDLE :
                case
                    input = check_status : SYSTEM_CHECK;
                    TRUE : IDLE;
                esac;

            state = SYSTEM_CHECK :
                case
                    input = start & !sensors.obstacle_detected : DRIVING;
                    TRUE : SYSTEM_CHECK;
                esac;

            state = DRIVING :
                case
                    input = turn : TURNING;
                    input = detect_stop_sign : STOPPED;
                    input = detect_red_light & sensors.red_light_detected : STOPPED;
                    input = change_lane & !sensors.obstacle_detected : CHANGING_LANE;
                    input = detect_obstacle : OBSTACLE_DETECTED;
                    TRUE : DRIVING;
                esac;

            state = TURNING :
                case
                    input = turn_completed : DRIVING;
                    TRUE : TURNING;
                esac;    
            
            state = OBSTACLE_DETECTED :
                case
                    input = brake & sensors.obstacle_detected : STOPPED;
                    TRUE : OBSTACLE_DETECTED;
                esac;

             state = CHANGING_LANE :
                case
                    input = change_lane_completed : DRIVING;
                    TRUE : CHANGING_LANE;
                esac;
            
            state = STOPPED :
                case
                    input = resume & !sensors.obstacle_detected : DRIVING;
                    input = detect_green_light &sensors.green_light_detected : DRIVING;
                    input = park : PARKED;
                    TRUE : STOPPED;
                esac;

            state = PARKED :
                case
                    input = stop : IDLE;
                    TRUE : PARKED;
                esac;
        esac;

    next(lane_position) :=
        case
            state = SYSTEM_CHECK & input = start & !sensors.obstacle_detected :
                case
                    lane_position = NaN : RIGHT;
                    TRUE : lane_position;
                esac;

            state = CHANGING_LANE & input = change_lane_completed :
                case
                    lane_position = RIGHT : CENTER;
                    lane_position = CENTER :
                        case
                            input = change_lane : RIGHT;
                            TRUE : LEFT;
                        esac;
                    lane_position = LEFT : CENTER;
                    TRUE : lane_position;
                esac;

            TRUE : lane_position;
        esac;

MODULE Sensors(input)
VAR
    obstacle_detected : boolean;
    red_light_detected : boolean;
    green_light_detected : boolean;
ASSIGN
    init(obstacle_detected) := FALSE;
    init(red_light_detected) := FALSE;
    init(green_light_detected) := FALSE;

    next(obstacle_detected) := 
        case
            input = detect_obstacle : TRUE;
            TRUE :  FALSE;
        esac;
    next(red_light_detected) := 
        case
            input = detect_red_light : TRUE;
            TRUE :  FALSE;
        esac;
    next(green_light_detected) := 
        case
            input = detect_green_light : TRUE;
            TRUE :  FALSE;
        esac;

MODULE Maneuver(input)
VAR
    lane_change_completed : boolean;
    completed_turn : boolean;
    
ASSIGN
    init(lane_change_completed) := FALSE;
    init(completed_turn) := FALSE;

    next(completed_turn) := 
        case
            input = turn_completed : TRUE;
            TRUE :  FALSE;
        esac;

    next(lane_change_completed) := 
        case
            input = change_lane_completed : TRUE;
            TRUE :  FALSE;
        esac;

