-- specification  G (state = DRIVING -> !sensors.obstacle_detected)  is true
-- specification  G (state = TURNING ->  F state = DRIVING)  is true
-- specification  G (state = DRIVING -> lane_position != NaN)  is true
-- GODO

--TODO:
-- fare in modo che detect_green_light avvenga solo dopo detect_red_light;

-- bugfix su questa situa:
-- state = TURNING
-- input = turn_completed
-- lane_position = RIGHT
-- sensors.obstacle_detected = TRUE
-- NON ROMPE LA SIM E LE LTL, Ã¨ SOLO UN BUG BRUTTO DA VEDERE

VAR
state : {IDLE, SYSTEM_CHECK, DRIVING, OBSTACLE_DETECTED, STOPPED, PARKED, CHANGING_LANE, TURNING};
input : {
    check_status, 
    no_input, 
    start, 
    brake, 
    resume, 
    park, 
    stop, 
    turn,
    change_lane, 
    change_lane_completed, 
    detect_obstacle, 
    detect_stop_sign,
    detect_red_light,
    detect_green_light,
    turn_completed
};
lane_position : {LEFT, CENTER, RIGHT, NaN}; -- pool per change_lane
sensors : Sensors(input);

LTLSPEC G (state = DRIVING -> !sensors.obstacle_detected) --OK
LTLSPEC G (state = DRIVING -> lane_position != NaN) --OK
LTLSPEC G (state = TURNING -> F(state = DRIVING)) -- OK 

ASSIGN
    init(state) := IDLE;
    init(input) := no_input; 
    init(lane_position) := NaN;

    -- def of input which cases can have
    next(input) :=
        case
            state = IDLE : {check_status, no_input};
            state = SYSTEM_CHECK : {start};
            state = DRIVING : {
                change_lane,
                turn, 
                detect_stop_sign,
                detect_obstacle, 
                detect_red_light,  
                no_input
            };
            state = TURNING : {turn_completed};
            state = CHANGING_LANE : {change_lane_completed};
            state = OBSTACLE_DETECTED : {brake};
            state = STOPPED : {detect_green_light, resume, park};
            state = PARKED : {stop, no_input};
            TRUE : no_input;
        esac;
    
    next(state) :=
        case
            state = IDLE :
                case
                    input = check_status : SYSTEM_CHECK;
                    TRUE : IDLE;
                esac;

            state = SYSTEM_CHECK :
                case
                    input = start & !sensors.obstacle_detected : DRIVING;
                    TRUE : SYSTEM_CHECK;
                esac;

            state = DRIVING :
                case
                    input = turn : TURNING;
                    input = change_lane & !sensors.obstacle_detected : CHANGING_LANE;
                    input = detect_obstacle : OBSTACLE_DETECTED;
                    TRUE : DRIVING;
                esac;

            state = TURNING :
                case
                    input = turn_completed : DRIVING;
                    TRUE : TURNING;
                esac;    
            
            state = OBSTACLE_DETECTED :
                case
                    input = brake & sensors.obstacle_detected : STOPPED;
                    TRUE : STOPPED;
                esac;

             state = CHANGING_LANE :
                case
                    input = change_lane_completed : DRIVING;
                    TRUE : CHANGING_LANE;
                esac;
            
            state = STOPPED :
                case
                    input = resume & !sensors.obstacle_detected : DRIVING;
                    input = detect_green_light : DRIVING;
                    input = park : PARKED;
                    TRUE : STOPPED;
                esac;

            state = PARKED :
                case
                    input = stop : IDLE;
                    TRUE : PARKED;
                esac;
            TRUE : state;
        esac;

    next(lane_position) :=
        case
            state = SYSTEM_CHECK & input = start & !sensors.obstacle_detected :
                case
                    lane_position = NaN : RIGHT;
                    TRUE : lane_position;
                esac;

            state = CHANGING_LANE & input = change_lane_completed :
                case
                    lane_position = RIGHT : CENTER;
                    lane_position = CENTER :
                        case
                            input = change_lane : RIGHT;
                            TRUE : LEFT;
                        esac;
                    lane_position = LEFT : CENTER;
                    TRUE : lane_position;
                esac;
            TRUE : lane_position;
        esac;

MODULE Sensors(input)
VAR
    obstacle_detected : boolean;
ASSIGN
    init(obstacle_detected) := FALSE;

    next(obstacle_detected) := 
        case
            input = detect_obstacle : TRUE;
            input = resume : FALSE;
            input = change_lane_completed : FALSE;
            TRUE :  FALSE;
        esac;