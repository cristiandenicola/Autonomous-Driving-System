MODULE main

--- VAR definition
VAR
  state : {SystemCheck, Idle, Driving, ObstacleDetected, Stopped, TurningLeft, TurningRight, EmergencyBraking, ChangingLanes, CruiseControl, Reversing, Parked};

  --- external modules integrations
  sensors : Sensors(input);
  speedControl : SpeedControl(input);
  maneuver : Maneuver(input);

--- initial state
-- nb: the def initial state should be idle, but for a logical way we preferred to use a "system check" state.
ASSIGN
  init(state) := SystemCheck;

  --- state transition case 
  next(state) :=
    case
      -- T SystemCheck to DEF
      state = SystemCheck : Idle;

      -- T states in which idle can pass
      state = Idle : {Driving, Parked};

      -- all possible actions and state transitions that the autonomous system can perform when it is in the Driving state.
      -- each line represents an option that the system can consider based on input received from sensors or other system components.
      -- nb. the fist case in an automatic transition based on what the sensor sense, the others (input) require specific commands sent to the system.
      state = Driving : 
        case
          sensors.obstacleDetected : ObstacleDetected; 
          input = stop : Stopped; -- logic is "if the system send a stop signal, the T will be Driving -> Stopped"
          input = turn_left : TurningLeft;
          input = turn_right : TurningRight;
          input = emergency_brake : EmergencyBraking;
          input = change_lane & sensors.laneClear : ChangingLanes; -- if and only if both true
          input = activate_cruise : CruiseControl;
          input = reverse : Reversing;
          input = park : Parked;
          TRUE : Driving; -- DEFAULT case. If none of the above conditions are met, the system remains in the Driving state.
        esac;

      -- transitions that the autonomous system can perform in ObstacleDetected state 
      state = ObstacleDetected : 
        case
          sensors.clearObstacle : Driving;
          input = stop : Stopped;
          input = emergency_brake : EmergencyBraking;
          TRUE : ObstacleDetected;
        esac;

      -- transitions that the autonomous system can perform in Stopped state 
      state = Stopped : 
        case
          input = resume : Driving;
          input = park : Parked;
          TRUE : Stopped;
        esac;

      -- transitions that the autonomous system can perform in TurningLeft state
      -- nb. initially TurningLeft was really simple, just a "after completing the turn, returns to driving", 
      -- but we thought that maybe during a turn there might be a crosswalk etc.
      state = TurningLeft : 
        case
          maneuver.completeTurn : Driving;
          sensors.obstacleDetected : ObstacleDetected;
          input = emergency_brake : EmergencyBraking;
          TRUE : TurningLeft;
        esac;

      -- transitions that the autonomous system can perform in TurningRight state
      -- same reasoning as before
      state = TurningRight : 
        case
          maneuver.completeTurn : Driving;
          sensors.obstacleDetected : ObstacleDetected;
          input = emergency_brake : EmergencyBraking;
          TRUE : TurningRight;
        esac;

      -- transitions that the autonomous system can perform in EmergencyBraking state
      state = EmergencyBraking : 
        case
          input = complete_braking : Stopped;
          sensors.clearObstacle : Driving;
          TRUE : EmergencyBraking;
        esac;

      -- transitions that the autonomous system can perform in ChangingLanes state
      state = ChangingLanes : 
        case
          maneuver.completeLaneChange : Driving;
          sensors.obstacleDetected : ObstacleDetected;
          input = emergency_brake : EmergencyBraking;
          TRUE : ChangingLanes;
        esac;

      -- transitions that the autonomous system can perform in CruiseControl state
      state = CruiseControl : 
        case
          input = deactivate_cruise : Driving;
          sensors.obstacleDetected : ObstacleDetected;
          input = emergency_brake : EmergencyBraking;
          TRUE : CruiseControl;
        esac;

      -- transitions that the autonomous system can perform in Reversing state
      state = Reversing : 
        case
          input = complete_reverse : Driving;
          sensors.obstacleDetected : ObstacleDetected;
          input = emergency_brake : EmergencyBraking;
          TRUE : Reversing;
        esac;

      -- transitions that the autonomous system can perform in Parked state
      -- the next state will be idle, skipping the system check (just because has already been done initially).
      state = Parked : 
        case
          input = start : Idle;
          TRUE : Parked;
        esac;

      TRUE : state;
    esac;

-- DEF transition inputs
VAR
  input : {detect_obstacle, stop, turn_left, turn_right, emergency_brake, change_lane, activate_cruise, reverse, park, clear_obstacle, resume, complete_turn, complete_braking, complete_lane_change, deactivate_cruise, complete_reverse, start, no_input};

ASSIGN
  init(input) := no_input;

-- definition of modules
MODULE Sensors(input)
VAR
  obstacleDetected : boolean;
  clearObstacle : boolean;
  laneClear : boolean;

-- init of boolean VAR
ASSIGN
  init(obstacleDetected) := FALSE;
  init(clearObstacle) := FALSE;
  init(laneClear) := TRUE;

  --- DEF of input-based transitions
  -- T obstacleDetected will be true if and only if detect_obstacle and TRUE and clear_obstacle FALSE
  next(obstacleDetected) := 
    case
      input = detect_obstacle : TRUE;
      input = clear_obstacle : FALSE;
      TRUE : obstacleDetected;
    esac;

  next(clearObstacle) := 
    case
      input = clear_obstacle : TRUE;
      input = detect_obstacle : FALSE;
      TRUE : clearObstacle;
    esac;

  next(laneClear) := 
    case
      input = detect_obstacle : FALSE;
      input = change_lane : TRUE;
      input = clear_obstacle : TRUE;
      TRUE : laneClear;
    esac;

MODULE SpeedControl(input)
VAR
  cruiseActive : boolean;

ASSIGN
  init(cruiseActive) := FALSE;

  next(cruiseActive) := 
    case
      input = activate_cruise : TRUE;
      input = deactivate_cruise : FALSE;
      TRUE : cruiseActive;
    esac;

MODULE Maneuver(input)
VAR
  completeTurn : boolean;
  completeLaneChange : boolean;

ASSIGN
  init(completeTurn) := FALSE;
  init(completeLaneChange) := FALSE;

  next(completeTurn) := 
    case
      input = complete_turn : TRUE;
      input = no_input : FALSE;
      TRUE : completeTurn;
    esac;

  next(completeLaneChange) := 
    case
      input = complete_lane_change : TRUE;
      input = no_input : FALSE;
      TRUE : completeLaneChange;
    esac;


--TODO: DA CAPIRE PERCHE' QUESTE NON FUNZIONANO.
-- SONO CORRETTE MA SE RUNNO IL CODICE MI DA QUESTO OUTPUT :

-- TYPE ERROR file main.smv: line 210 : undefined identifier 'maneuver.state'
-- TYPE ERROR file main.smv: line 210 : undefined identifier 'maneuver.sensors.laneClear'
-- ERROR: Property " G (state = ChangingLanes -> sensors.laneClear) IN maneuve" is not correct or not well typed.

LTLSPEC
  -- safe prop
  G (state = ChangingLanes -> sensors.laneClear);
  -- globally means that if the state is ChangingLanes than laneClear MUST be true.
  -- simple logic T -> T

LTLSPEC
  -- safe prop
  G (state = Driving -> !sensors.obstacleDetected);
  -- globally means that if the state is Driving than obstacleDetected MUST be false.
  -- simple logic T -> T

LTLSPEC
  -- just a check for logical integrity.
  G (state = CruiseControl -> speedControl.cruiseActive);
  -- globally means that if the state is CruiseControl than cruiseActive MUST be true.