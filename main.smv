MODULE main

--- VAR definition
VAR
  state : {SystemCheck, Idle, Driving, ObstacleDetected, Stopped, TurningLeft, TurningRight, EmergencyBraking, ChangingLanes, CruiseControl, Reversing, Parked};
  input : {detect_obstacle, stop, turn_left, complete_turn, turn_right, emergency_brake, change_lane, activate_cruise, reverse, park, clear_obstacle, resume, complete_braking, complete_lane_change, deactivate_cruise, complete_reverse, start, no_input};

VAR
 sensors : Sensors(input);
 speedControl : SpeedControl(input);
 maneuver : Maneuver(input);

--- initial state
-- nb: the def initial state should be idle, but for a logical way we preferred to use a "system check" state.
ASSIGN
  init(state) := SystemCheck;
  init(input) := no_input;

   next(input) :=
    case
      state = Idle : {detect_obstacle, start};
      state = Driving : {detect_obstacle, stop, turn_left, turn_right, emergency_brake, change_lane, activate_cruise, no_input};
      state = ObstacleDetected : {clear_obstacle};
      state = Stopped : {reverse, park, clear_obstacle, resume, no_input};
      state = TurningLeft : {complete_turn, detect_obstacle, clear_obstacle, emergency_brake, no_input};
      state = TurningRight : {complete_turn, detect_obstacle, clear_obstacle, emergency_brake, no_input};
      state = EmergencyBraking : {complete_braking, no_input}; 
      state = ChangingLanes : {detect_obstacle, clear_obstacle, change_lane, complete_lane_change, emergency_brake, no_input}; 
      state = CruiseControl : {deactivate_cruise, emergency_brake,  no_input}; 
      state = Reversing : {detect_obstacle, clear_obstacle, complete_reverse, emergency_brake, stop, park, resume, no_input}; 
      state = Parked : {start, no_input};
      TRUE : no_input;
    esac;

  --- state transition case 
  next(state) :=
    case
      -- T SystemCheck to DEF
      state = SystemCheck : Idle;
      state = Idle :
        case
          input = detect_obstacle : ObstacleDetected;
          sensors.clearObstacle & input = start : Driving;
          TRUE : Idle;
        esac;
      -- all possible actions and state transitions that the autonomous system can perform when it is in the Driving state.
      -- each line represents an option that the system can consider based on input received from sensors or other system components.
      -- nb. the fist case in an automatic transition based on what the sensor sense, the others (input) require specific commands sent to the system.
      state = Driving : 
        case
          sensors.obstacleDetected : ObstacleDetected;
          input = detect_obstacle : ObstacleDetected;  -- Transizione se l'ostacolo viene rilevato e sensors.obstacleDetected è vero
          input = stop : Stopped; -- logic is "if the system send a stop signal, the T will be Driving -> Stopped"
          input = turn_left : TurningLeft;
          input = turn_right : TurningRight;
          input = emergency_brake : EmergencyBraking;
          input =  change_lane & sensors.laneClear : ChangingLanes; -- if and only if both true
          input = activate_cruise : CruiseControl;
          --sensors.clearObstacle & input = clear_obstacle : Driving;
          TRUE : Driving;
        esac;

      -- transitions that the autonomous system can perform in ObstacleDetected state 
      state = ObstacleDetected : 
        case
          sensors.clearObstacle : Driving;
          sensors.clearObstacle & input = resume : Driving;
          input = emergency_brake : EmergencyBraking;
          input = stop : Stopped;
          TRUE : ObstacleDetected;
        esac;

      -- transitions that the autonomous system can perform in Stopped state 
      state = Stopped : 
        case
          input = resume & sensors.clearObstacle : Driving; -- if and only if both true
          input = park : Parked;
          input = reverse : Reversing;
          input = clear_obstacle : Driving;
          TRUE : Stopped;
        esac;

      -- transitions that the autonomous system can perform in TurningLeft state
      -- nb. initially TurningLeft was really simple, just a "after completing the turn, returns to driving", 
      -- but we thought that maybe during a turn there might be a crosswalk etc.
      state = TurningLeft : 
        case
          sensors.obstacleDetected : ObstacleDetected;
          maneuver.completeTurn : Driving;
          input = complete_turn : Driving;
          input = emergency_brake : EmergencyBraking;
          TRUE : TurningLeft;
        esac;

      -- transitions that the autonomous system can perform in TurningRight state
      -- same reasoning as before
      state = TurningRight : 
        case
          sensors.obstacleDetected : ObstacleDetected;
          maneuver.completeTurn : Driving;
          input = complete_turn : Driving;
          input = emergency_brake : EmergencyBraking;
          TRUE : TurningRight;
        esac;

      -- transitions that the autonomous system can perform in EmergencyBraking state
      state = EmergencyBraking : 
        case
          input = complete_braking : Stopped;
          -- si deve fermare e passare in stopped
          TRUE : Stopped;
        esac;

      -- transitions that the autonomous system can perform in ChangingLanes state
      state = ChangingLanes : 
        case
          sensors.laneClear : Driving;
          maneuver.completeLaneChange : Driving;
          sensors.obstacleDetected : ObstacleDetected;
          input = detect_obstacle : ObstacleDetected;
          input = emergency_brake : EmergencyBraking;
          TRUE : ChangingLanes;
        esac;

      -- transitions that the autonomous system can perform in CruiseControl state
      state = CruiseControl : 
        case
          input = deactivate_cruise : Driving;
          input = emergency_brake : EmergencyBraking;
          TRUE : CruiseControl;
        esac;

      -- transitions that the autonomous system can perform in Reversing state
      state = Reversing : 
        case
          input = complete_reverse : Driving;
          sensors.obstacleDetected : ObstacleDetected;
          input = emergency_brake : EmergencyBraking;
          input =  stop : Stopped;
          input =  park : Parked;
          input =  resume : Driving ;
          TRUE : Reversing;
        esac;

      -- transitions that the autonomous system can perform in Parked state
      -- the next state will be idle, skipping the system check (just because has already been done initially).
      state = Parked : 
        case
          input = start : Idle;
          TRUE : Parked;
        esac;
      TRUE : state;
    esac;

LTLSPEC
  -- Proprietà di sicurezza: se lo stato è ChangingLanes, laneClear deve essere vero
  G (state = ChangingLanes -> sensors.laneClear);

LTLSPEC
  -- Proprietà di sicurezza: se lo stato è Driving, obstacleDetected deve essere falso
  G (state = Driving -> !sensors.obstacleDetected);

LTLSPEC
  -- Verifica integrità logica: se lo stato è CruiseControl, cruiseActive deve essere vero
  G (state = CruiseControl -> speedControl.cruiseActive);

LTLSPEC 
  G (state = Driving -> !((state = Reversing) | (state = Parked)));

LTLSPEC 
  G (state = EmergencyBraking -> X(state = Stopped));

LTLSPEC 
  G (state = Reversing -> X !(state = CruiseControl));

LTLSPEC 
  G (state = Reversing -> X !(state = ChangingLanes));


-- definition of modules
MODULE Sensors(input)
VAR
  obstacleDetected : boolean;
  clearObstacle : boolean;
  laneClear : boolean;

-- init of boolean VAR
ASSIGN
  init(obstacleDetected) := FALSE;
  init(clearObstacle) := TRUE;
  init(laneClear) := TRUE;

  --- DEF of input-based transitions
  -- T obstacleDetected will be true if and only if detect_obstacle and TRUE and clear_obstacle FALSE
  next(obstacleDetected) := 
    case
      input = detect_obstacle : TRUE;
      input = clear_obstacle : FALSE;
      TRUE : obstacleDetected;
    esac;

  next(clearObstacle) := 
    case
      input = clear_obstacle : TRUE;
      input = detect_obstacle : FALSE;
      TRUE : clearObstacle;
    esac; 

  next(laneClear) := 
    case
      input = detect_obstacle : FALSE;
      input = change_lane : TRUE;
      input = clear_obstacle : TRUE;
      TRUE : laneClear;
    esac;

MODULE SpeedControl(input)
VAR
  cruiseActive : boolean;

ASSIGN
  init(cruiseActive) := FALSE;

  next(cruiseActive) := 
    case
      input = activate_cruise : TRUE;
      input = deactivate_cruise : FALSE;
      TRUE : cruiseActive;
    esac;

MODULE Maneuver(input)
VAR
  completeTurn : boolean;
  completeLaneChange : boolean;
  --- AGGIUNGERE COMPLETE REV
  --- complete frenata


ASSIGN
  init(completeTurn) := TRUE;
  init(completeLaneChange) := FALSE;

  next(completeTurn) := 
    case
      input = complete_turn : TRUE;
      input = no_input : FALSE;
      TRUE : completeTurn;
    esac;

  next(completeLaneChange) := 
    case
      input = complete_lane_change : TRUE;
      input = no_input : FALSE;
      TRUE : completeLaneChange;
    esac;